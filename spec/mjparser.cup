package com.kosta.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import com.kosta.pp1.ast.*;

parser code {:

    Logger log = Logger.getLogger(getClass());

    // Error reporting methods
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append(" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}



terminal PROG, RETURN, CONST, CLASS, INTERFACE, EXTENDS, MAP, DO, WHILE, IF, ELSE, CONTINUE, BREAK, PRINT;
terminal READ,VOID, PLUS, POSTINC, MINUS, POSTDEC, MUL, DIV, MOD, NEW, UNION;
terminal EQUAL, DOT, COMMA, SEMI, LPAREN, RPAREN, LBRACE, RBRACE, LSQBRACE, RSQBRACE, GT, LT, EQ, NEQ, GTE, LTE,AND, OR;
terminal Integer NUMBER;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;
terminal String IDENT;

nonterminal Declarations, MethodDeclarations;
nonterminal ConstDeclarations, LocalVarDeclarations, ClassDeclaration, InterfaceDeclaration; 
nonterminal MethodDeclaration;
nonterminal ClassBody, Literal, IdDeclaration, IdDefinition, ArrayDeclaration;
nonterminal Statements, Statement, MethodSignature, FunctionParameters;
nonterminal Mulop, Addop, Relop;
nonterminal IfStatement, DoWhile, Designator, DesignatorStatement, PrintStatement, ReturnStatement;
nonterminal Matched, Unmatched;
nonterminal Expression, Expressions, ActPars;
nonterminal MethodChain, ArrayChain, Condition, ConditionTerm, ConditionFact;
nonterminal AddTerm, Term, Factor, NewType, FunctionArgumentList, ConstDeclaration;
nonterminal VarDeclarationList, MethodSignatures, InterfaceBody, MethodList;
nonterminal InterfaceElements, InterfaceElement, DesignatorTail, VarDeclarationListGlobal;
nonterminal ProgName, Program;
nonterminal Type, VarDeclaration, IdDefinitionList, ConstDeclarationList, IdentDecl;

precedence left ELSE;

/* Grammar rules start here */
start with Program;
/* Helper rules */
Literal       ::=(CHAR) CHAR_CONST:val | (BOOL) BOOL_CONST:val | (NUMBER) NUMBER:val;
IdDeclaration ::= (IdDecl) IdentDecl | (ArrayDecl)ArrayDeclaration;
IdentDecl ::= (IdentDecl)IDENT:name;
ArrayDeclaration ::= (ArrayDeclaration)IDENT:name LSQBRACE RSQBRACE;
IdDefinition  ::=(IdDefinition) IDENT:name EQUAL Literal:val;
ClassBody ::= LBRACE LocalVarDeclarations LBRACE MethodDeclarations RBRACE RBRACE; 
Type ::= (Type) IDENT:typeName;
Mulop ::= MUL | DIV | MOD;
Addop ::= PLUS | MINUS;
Relop ::= GT | LT | EQ | NEQ | GTE | LTE;

/* Main rules */
Program ::= (Program) PROG ProgName:p Declarations LBRACE MethodDeclarations RBRACE;

ProgName ::= (ProgName) IDENT:name;

Declarations ::= /* nothing */
               | Declarations ConstDeclarationList
               | Declarations VarDeclarationListGlobal
               | Declarations ClassDeclaration
               | Declarations InterfaceDeclaration
               ;
               
               
VarDeclarationListGlobal ::= (GlobalVarDeclaration) VarDeclarationList:DeclarationList
            | error SEMI:l 
                {: parser.report_error("Oporavak od greske pri dodeli vrednosti na liniji " + lleft , null); :}
            | error COMMA:l                                                                   
                {: parser.report_error("Oporavak od greske pri dodeli vrednosti na liniji "+ lleft , null); :}
            ;

FunctionParameters ::= (FunctionParameterDeclConcrete) Type IdDeclaration
					|  (FunctionParameterDeclRecursive) FunctionParameters COMMA Type IdDeclaration
					;
FunctionArgumentList ::= /* nothing */ 
                      | (FuncPars)FunctionParameters:FunctionParameters
                      ;

MethodSignature ::=  (MethodSignatureTyped) Type:Type IDENT:MethodName LPAREN FunctionArgumentList:FunctionArgumentList RPAREN
                  |  (MethodSignatureVoid)VOID IDENT:MethodName LPAREN FunctionArgumentList:FunctionArgumentList RPAREN;

MethodDeclaration ::= (MethodDefinition)MethodSignature:MethodSignature LocalVarDeclarations:VarDecls LBRACE Statements RBRACE
					| (MethodDefinitionNoLocals)MethodSignature:MethodSignature LBRACE Statements RBRACE
                    ;

MethodDeclarations ::= /* nothing */
                     | MethodDeclarations MethodDeclaration
                     ;


                     
ConstDeclarationList ::= (ConstDeclarationList) CONST Type:type IdDefinitionList:defList SEMI;

IdDefinitionList ::= (IdDefinitionListConcrete)  IdDefinition:IdDefinition
                   | (IdDefinitionListRecursive) IdDefinitionList COMMA IdDefinition:IdDefinition;


LocalVarDeclarations ::=   (LocalVarDeclarationsRecursive) LocalVarDeclarations:LocalVarDeclarations VarDeclarationList:declList
						 | (LocalVarDeclarationsConcrete)VarDeclarationList:declList
					     ;

VarDeclarationList ::= (VarDeclarationList) Type:type VarDeclaration:VarDeclaration SEMI;

VarDeclaration ::=   (VarDecl)  IdDeclaration:IdDeclaration
                   | (VarDeclRecursive)VarDeclaration:VarDeclaration COMMA IdDeclaration:IdDeclaration
                   ;

ClassDeclaration ::=  CLASS IDENT ClassBody
                    | CLASS IDENT EXTENDS Type ClassBody
                    ;

InterfaceDeclaration ::= INTERFACE IDENT LBRACE InterfaceBody RBRACE;


InterfaceBody ::= InterfaceElements;

InterfaceElements ::= /* nothing */
                   | InterfaceElements InterfaceElement;

InterfaceElement ::= MethodSignature SEMI
                   | MethodDeclaration;

Statements ::= /* nothing */
			  | (StatementsRecursive)Statements:Statements Statement:Statement
			  ;

Statement ::= (DesignatorStmt)DesignatorStatement SEMI
           | (IfStmt)IfStatement 
           | BREAK SEMI
           | CONTINUE SEMI
           | ReturnStatement
           | READ LPAREN Designator RPAREN SEMI
           | PrintStatement
           | (WhileStmt)DoWhile
           | LBRACE Statements RBRACE
		   | error SEMI:l {: parser.report_error("Oporavak od greske pri dodeli vrednostina liniji " +lleft,null); :}
           ;

ReturnStatement ::= RETURN SEMI
				  | RETURN Expression SEMI
				  ;           
PrintStatement ::= PRINT LPAREN Expression RPAREN SEMI
				|  PRINT LPAREN Expression COMMA NUMBER RPAREN SEMI
				;
				
DoWhile ::=  (WhileCond) DO Statement WHILE LPAREN Condition RPAREN SEMI
		   | (WhileDesignator) DO Statement WHILE LPAREN Condition COMMA DesignatorStatement RPAREN SEMI
		   | (WhileSimple) DO Statement WHILE LPAREN RPAREN SEMI
		   ;

Condition ::= (ConditionConcrete)  ConditionTerm
			| (ConditionRecursive) Condition OR ConditionTerm
			;
			
ConditionTerm ::= ConditionFact
				| ConditionTerm AND ConditionFact
				;

ConditionFact ::= Expression
				| Expression Relop Expression
				;
 
DesignatorStatement ::= (VarDesignation) Designator:Designator EQUAL Expression:Expr
					  | Designator LPAREN ActPars RPAREN
					  | (PostInc)Designator:Designator POSTINC
					  | (PostDec)Designator:Designator POSTDEC
					  | (SetDesignation)Designator:DesignatorLeft EQUAL Designator:Operand1 UNION Designator:Operand2
					  ;

Designator ::=(Designator) IDENT:name DesignatorTail:tail;

DesignatorTail ::= /* nothing */
                 | DOT IDENT DesignatorTail
                 | LSQBRACE Expression RSQBRACE DesignatorTail;

					  
ActPars ::= /* nothing */
		 | Expressions
		 ;

Expressions ::= Expression
			 | Expressions COMMA Expression
			 ;

Expression ::= Designator MAP Designator
			|  (ExprMinusAddTerm) MINUS AddTerm 
			|  (ExprAddTerm)AddTerm
			;

AddTerm ::= (AddTermConcrete) Term:Term
		|   (AddTermRecursive) AddTerm:AddTerm Addop Term:Term	
		;
		
Term ::= (TermConcrete) Factor:Factor
	 |   (TermRecursive) Term:Term Mulop Factor:Factor
	 ;		

Factor ::= (FactorLiteral) Literal:Literal
		|  LPAREN Expression RPAREN
		|  (FactorNewType) NewType
		|  Designator LPAREN ActPars RPAREN
		|  (FactorIdent) Designator
		;
		
NewType ::= NEW Type LSQBRACE Expression RSQBRACE
		|   NEW Type LPAREN ActPars RPAREN
		;

IfStatement ::= (IfOnly) IF LPAREN Condition RPAREN Statement
              | (IfElse) IF LPAREN Condition RPAREN Statement ELSE Statement
              ;
